<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>使用关系型数据库实现事件源模式 | -LAN-&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="关系型数据库是日常开发中最常用的数据库类型，本文记载使用关系型数据库实现事件源模式的要点和一些问题。 要阅读本篇文章，你可能需要先自行了解关系型数据库、事件源模式和领域驱动设计相关知识。  事件存储首先考虑事件的存储，实际上只需要四个字段， DDL 如下（以 PostgreSQL 为例）： 12345678CREATE TABLE events(    id        SERIAL">
<meta property="og:type" content="article">
<meta property="og:title" content="使用关系型数据库实现事件源模式">
<meta property="og:url" content="https://laipz8200.github.io/2022/05/16/implement-event-sourcing/">
<meta property="og:site_name" content="-LAN-&#39;s Blog">
<meta property="og:description" content="关系型数据库是日常开发中最常用的数据库类型，本文记载使用关系型数据库实现事件源模式的要点和一些问题。 要阅读本篇文章，你可能需要先自行了解关系型数据库、事件源模式和领域驱动设计相关知识。  事件存储首先考虑事件的存储，实际上只需要四个字段， DDL 如下（以 PostgreSQL 为例）： 12345678CREATE TABLE events(    id        SERIAL">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-16T14:35:51.000Z">
<meta property="article:modified_time" content="2022-07-07T15:36:52.882Z">
<meta property="article:author" content="laipz8200">
<meta property="article:tag" content="event sourcing">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="-LAN-'s Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">-LAN-&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/me">About Me</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://laipz8200.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-implement-event-sourcing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/16/implement-event-sourcing/" class="article-date">
  <time class="dt-published" datetime="2022-05-16T14:35:51.000Z" itemprop="datePublished">2022-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      使用关系型数据库实现事件源模式
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>关系型数据库是日常开发中最常用的数据库类型，本文记载使用关系型数据库实现事件源模式的要点和一些问题。</p>
<p>要阅读本篇文章，你可能需要先自行了解关系型数据库、事件源模式和领域驱动设计相关知识。</p>
</blockquote>
<h2 id="事件存储"><a href="#事件存储" class="headerlink" title="事件存储"></a>事件存储</h2><p>首先考虑事件的存储，实际上只需要四个字段， DDL 如下（以 PostgreSQL 为例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> events</span><br><span class="line">(</span><br><span class="line">    id        SERIAL      <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    stream_id <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    version   <span class="type">BIGINT</span>      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    data      TEXT        <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> (stream_id, version)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中， <code>stream_id</code> 是实体或聚合的唯一标识，也可以把这个字段叫做 <code>name</code> 或者其他你喜欢的名字， <code>version</code> 是事件的版本，由于事件是只追加的，版本会不断增加，并且对于同一个实体或聚合来说，版本号不会有重复。</p>
<p><code>id</code> 是事件的标识符，由数据库生成即可。</p>
<p>使用这种简单的结构，我们已经可以实现两种事件源模式需要的功能了。首先是获取事件流：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, stream_id, version, data <span class="keyword">FROM</span> events </span><br><span class="line">    <span class="keyword">WHERE</span> stream_id <span class="operator">=</span> :stream_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> version <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<p>根据有序的事件流，我们可以重建出一个实体或聚合的最新状态，这是事件源模式的关键功能。</p>
<p>第二项功能是记录事件，使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> events(stream_id, version, data)</span><br><span class="line">    <span class="keyword">VALUES</span>(:stream_id, :<span class="keyword">current</span><span class="operator">+</span><span class="number">1</span>, :data);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这里的 <code>current+1</code> 仅仅表示插入数据时应该让版本增加 1，而不是可以直接在 SQL 语句中这样写。<br>考虑到主流关系型数据库的默认隔离级别，这种写法会产生一些并发问题。（对于 PostgreSQL ，可以指定隔离级别为 <em>Repeatable Read</em> ）</p>
<h2 id="投影-PROJECTION"><a href="#投影-PROJECTION" class="headerlink" title="投影 (PROJECTION)"></a>投影 (PROJECTION)</h2><p>事件源模式的另一个问题是无法像传统表结构那样进行过滤，我们使用投影来解决这个问题。</p>
<p>投影是通过提前聚合事件形成的一种视图，我们既可以同步更新投影，也可以异步更新投影。在异步更新时，系统将获得更高的性能，但会存在一定延迟，这时的系统实现的是 <em>最终一致性</em> 。</p>
<p>实现最终一致性并不是一件容易的事，在关系型数据库中，为了简单，我们可以先同步更新投影，这种情况下应该利用关系库的一致性保证，即使用 <strong>事务</strong>。</p>
<p>每个事务中我们做两件事：</p>
<ul>
<li>插入新的事件</li>
<li>更新投影</li>
</ul>
<p>因为事件存储是整个系统的唯一数据源，所以投影可以被轻易放弃、调整结构，只需要重放所有事件即可生成新的投影用来适配客户端的查询需求。</p>
<h2 id="快照-SNAPSHOT"><a href="#快照-SNAPSHOT" class="headerlink" title="快照 (SNAPSHOT)"></a>快照 (SNAPSHOT)</h2><p>快照解决事件源模式中的另一个问题：当事件数量不断增加时，重建一个实体或聚合的成本也会不断增加。</p>
<p>可以将快照视为一种特殊的投影，与投影相比，快照最大的不同点是它需要保存版本信息，这样我们就可以在重建时先查询快照，然后仅将快照对应版本之后发生的事件应用在实体或聚合上。</p>
<p>和投影一样，使用关系库时，我们可以在同一个事务中更新快照，不过快照并不需要频繁更新，通常每 50-100 个版本更新一次即可<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[实现领域驱动设计](https://book.douban.com/subject/25844633/)
">[1]</span></a></sup>。</p>
<h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><p>引入快照和投影之后，我们失去了一些灵活性，其中很重要的一点就是要如何修改投影和快照的结构。</p>
<p>当条件允许时，最简单的方式是停止服务，删除旧的投影和快照表，然后重放事件并生成一份新的表。然而生产服务并不会允许我们这样做，因此当需要升级时，我们应该考虑以下步骤：</p>
<ol>
<li>创建新的投影和快照表。</li>
<li>修改程序，当新的事件写入时，旧表和新表都应该被更新，当然，只有当实体已经存在于新表中时，它才会被更新。</li>
<li>如果有新的实体或聚合被创建，它会同时被保存到两个表中。</li>
<li>最后，我们重放所有已有的事件，并将它们聚合后的结果写入新表中。</li>
<li>当以上步骤完成，新旧两个版本的数据会同步更新，此时我们可以删除旧表和相关逻辑。</li>
</ol>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>最后，让我们考虑一下性能问题。当系统成长到一定规模时，我们会很自然地想到采用异步更新投影的方式来改善性能，事件源模式最终通常会引入消息队列（甚至是 Kafka ）。</p>
<p>然而在关系库和消息队列之间并没有一种方式可以维持一致性，无论在数据库事务的哪个阶段发送消息，都可能产生一些副作用。</p>
<p>由于使用不同组件，我们没有方法可以彻底消除副作用，但可以通过一些手段来实现最终一致性：</p>
<ol>
<li>创建一张队列 (queue) 表 ，用来存放新生成的事件。</li>
<li>当有新的事件生成时，同时写入事件存储和队列。</li>
<li>使用一个 <strong>单线程的</strong> 程序轮询队列，分批取出其中的事件并发送到消息队列，然后从队列中删除这些事件。</li>
<li>创建事件监听器，从消息队列中获取事件并更新投影和快照。</li>
</ol>
<p>注意以上操作中的第 3 步，消息发送后，删除操作依然有可能失败，此时，同一事件可能被多次发送到消息队列中。<br>不过问题不大，由于事件存在版本，消费者可以轻松找出不需要处理的事件并丢弃它们。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://softwaremill.com/implementing-event-sourcing-using-a-relational-database/">Implementing event sourcing using a relational database</a></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25844633/">实现领域驱动设计</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://laipz8200.github.io/2022/05/16/implement-event-sourcing/" data-id="cl5b6ziht00029gou1azycnxe" data-title="使用关系型数据库实现事件源模式" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/event-sourcing/" rel="tag">event sourcing</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/05/19/simple-api-with-rails/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          珍惜时间，Ruby on Rails API 开发指北
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/active-record/" rel="tag">active record</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-mapper/" rel="tag">data mapper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/event-sourcing/" rel="tag">event sourcing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rails/" rel="tag">rails</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ruby/" rel="tag">ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" rel="tag">企业应用架构模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8/" rel="tag">数据映射器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/" rel="tag">领域模型</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/active-record/" style="font-size: 10px;">active record</a> <a href="/tags/data-mapper/" style="font-size: 10px;">data mapper</a> <a href="/tags/event-sourcing/" style="font-size: 10px;">event sourcing</a> <a href="/tags/rails/" style="font-size: 10px;">rails</a> <a href="/tags/ruby/" style="font-size: 10px;">ruby</a> <a href="/tags/%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">企业应用架构模式</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%98%A0%E5%B0%84%E5%99%A8/" style="font-size: 10px;">数据映射器</a> <a href="/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">领域模型</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/07/data-mapper-pattern/">数据映射器和模型-数据源分离</a>
          </li>
        
          <li>
            <a href="/2022/05/19/simple-api-with-rails/">珍惜时间，Ruby on Rails API 开发指北</a>
          </li>
        
          <li>
            <a href="/2022/05/16/implement-event-sourcing/">使用关系型数据库实现事件源模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 laipz8200<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/me" class="mobile-nav-link">About Me</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>